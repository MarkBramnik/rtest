# rtest - Remote integration testing framework for JVM applications

**rtest** (_r_ stands for _remote_) is a framework for integration testing of products running on JVM.

The framework is developed out of beliefs gained by technical experience and takes some basic assumptions
  
### Beliefs:
* Testing is a developer's friend. The test development should be **easy** and **fun**.

* Rtest framework is developed for *integration* tests. For unit and system/functional tests other frameworks will work much better

* The main purpose of integration test is checking the behaviour of 
component in the real / semi-real environment, so the best way to 
check the running component is connecting to the up-and-running application and executing the test 
right on the JVM that runs that application.

### Basic Assumptions:
 
 
##### The application can be of any type:

* Tomcat or Jetty running the application WAR
* An application running some kind of embedded web container (like Jetty)
* Not a web application at all (e.g. no HTTP / REST layer exposed at all)

##### The application will benefit the most from this framework if it uses dependency injection container
* Currently there is an integration with spring and its possible to *attach* the test to the application context,
  but again, its not a necessarily requirement. If DI container is not used in the application, the framework will work but
  accessing the components inside the running server will be under the application developer's responsibility

##### The framework can be seamlessly supported by any tool that runs the tests:
* IDE for development purposes
* ANT/Maven/Gradle for build
* Programmatic invocation of test for whatever purpose

##### The codebase of tests themselves should not be a part of the application distribution. Tests can be still run on top of this application
* For example, if the application is built as a WAR file that will be deployed in production, the jar module of tests should not be a part of the WAR
This allows really agile and fast development of test itself and doesn't bloat the distribution with unnecessary code

### Requirements:

* The JVM running the application will be of version 7 at least (java 8 is supported of course)
* The tests themselves will be written in [Spock framework](http://spockframework.org/) So some learning curve is required
The good news are that Spock itself is really a good tool so even if you don't know groovy, you'll be able to run spock after probably a hour of study
*Later on you'll probably discover that it works better even for other types of tests ;)*

>The concepts behind this framework can be easily implemented on top of Junit as well, Spock was taken solely 
>out of belief that developing tests in spock is much more easy and fun process than developing tests with JUnit (4.x at least).

* The framework _does require some change in application_ namely exposing a component that will accept remote connection on some tcp port 
and (optionally) the folder for storing the server side test reports. Since the server side component is fully customizable,
its perfectly valid to turn it off in production/protect the port with some kind of firewall 

### Basic Flow

Here is a schematic high level explanation of how to use the rtest framework

* The architecture is a well-known client-server architecture. The application acts as a server and as such it should expose an opened port to accept connections.

*  The test running will always initiated on remote JVM (IDE, maven surefire plugin, and so forth) which will be referred as a client.  
   The host/port of the remote server should be supplied through some system variables (there are defaults of course)
   The test code will be compiled with server side classes in classpath, because the nature of test assumes that it has an access to the server side component

*  When the test actually starts, the framework contacts the server and asks to run the test. Since the bytecode of the test doesn't exist on server at this point, it will supplied dynamically,
   the framework handles this transparently

*  The server runs the test and obtains the results

*  The results get serialized back to the client

*  The client tool will render the result of test execution, like this test has been run locally and finished with the obtained result.

*  Since the reports can be generated by spock as a part of the framework, they are stored on the server side, but can be requested by client after the test has actually been run.
    
    
    
The basic flow is depicted in the following figure 

![figure 1](https://cloud.githubusercontent.com/assets/12389201/21518634/91788606-ccf0-11e6-8391-6bb46bc5d894.png)

In this example we have a build system that triggers a test **Foo**. So the setup would be preparing the application and running it. 
For example if its a web application, the tomcat/jetty web container should be started with the war of the application

Once this happens the build tool can start triggering tests. 
The actual test code acts as a proxy for server side execution but from the point of view of building system its just transparent.
When the server runs the test code there can be failures in tests, or all the tests will run successfully. In any case the results will be obtained by the client side
and will be propagated to the build system.

### More explanations 

#### Creating a basic test

First of all we should create a test in a module that will have a dependency on the testing framework.


    <dependency>
      <groupId>org.rtest</groupId>
      <artifactId>rtest-framework</artifactId>
      <version>1.0-SNAPSHOT</version>
    </dependency>


This will bring the dependencies on groovy, spock, etc.
Note that this dependency should be added to both application and the module that will actually contain the integration tests

Now it time to create the first test

In plain spock all tests extends _spock.lang.Specification_ class. The basic test looks like this:


    class MySampleTest extends Specification {
      def "check that 1 and 1 is 2" () {
         expect:
         1 + 1 == 2
      }
    }

RTest introduces an abstraction of _org.rtest.spock.specification.RemoteTestSpecification_
So the basic test that runs with RTest will look like this:

    import org.rtest.spock.specification.RemoteTestSpecification 
    
    class MySampleRemoteTest extends RemoteTestSpecification {
      def "check that 1 and 1 is 2" () {
         expect:
         1 + 1 == 2
      }
    }

An attempt to run this test immediately will fail because the server application is not available
So we'll have to start the server. But before doing that we'll have to register the RTest class that will 
actually get the request from clients

RTest is totally agnostic of technology that is used on server. The only thing the developer should know is that the 
entry point of the server is _org.rtest.framework.server.RTestRemoteServer_ class

So it should be created and started by means of calling the _start()_ method on it
The instance of the server should be available in memory as long as the server runs.

When its time to close the application, one of the following methods should be called: _shutdown()_ / _shutdownNow()_ 
They work pretty much like thread pool methods - _shutdown_ will wait for the current thread(s) to finish the execution,
while _shutdownNow_ will attempt to interrupt the threads before actually shutting down the service

Here is an example of web listener definition like this:


    public class RTestIntegrationListener implements ServletContextListener {
        private RTestRemoteServer remoteServer;

        public void contextInitialized(ServletContextEvent servletContextEvent) {
            remoteServer = new RTestRemoteServer();
            remoteServer.start();
        }
    
        public void contextDestroyed(ServletContextEvent servletContextEvent) {
            remoteServer.shutdown();
        }
    }
    
Alternatively the RTestRemoteServer can be defined as a Spring bean or in any other way
TODO: Add spring bean declaration example

Now when the application is started the port 7890 is ready to accept connections and will allow running one test at a time

At this point we can start the application and when its up and running - to run the test just like its a regular unit test
If the configuration is done correctly, the test will be green.


So what's the hassle one might ask?
Lets slightly modify the test (ok, its not a real test, but it illustrates what actually happens)
The server application can be up and running during these manipulations:


    import org.rtest.spock.specification.RemoteTestSpecification 
    
    class MySampleRemoteTest extends RemoteTestSpecification {
      
      def "check that 1 and 1 is 2" () {
               expect:
               1 + 1 == 2
      }
      
      def "check that 1 and 1 is 2 but this time with fancy print" () {
         when:
         println "Hello RTest world"
         then:
         1 + 1 == 2
      }
    }

Lets rerun the test and we'll notice that the print message has appeared on server application stdout 

TODO: Add me!
