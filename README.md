# rtest - Remote integration testing framework for JVM applications

**rtest** (_r_ stands for _remote_) is a framework for integration testing of products running on JVM.

The framework is developed out of beliefs gained by technical experience and takes some basic assumptions
  
### Beliefs:
* Testing is a developer's friend. The test development should be **easy** and **fun**.

* Rtest framework is developed for *integration* tests. For unit and system/functional tests other frameworks will work much better

* The main purpose of integration test is checking the behaviour of 
component in the real / semi-real environment, so the best way to 
check the running component is connecting to the up-and-running application and executing the test 
right on the JVM that runs that application.

### Basic Assumptions:
 
 
##### The application can be of any type:

* Tomcat or Jetty running the application WAR
* An application running some kind of embedded web container (like Jetty)
* Not a web application at all (e.g. no HTTP / REST layer exposed at all)

##### The application will benefit the most from this framework if it uses dependency injection container
* Currently there is an integration with spring and its possible to *attach* the test to the application context,
  but again, its not a necessarily requirement. If DI container is not used in the application, the framework will work but
  accessing the components inside the running server will be under the application developer's responsibility

##### The framework can be seamlessly supported by any tool that runs the tests:
* IDE for development purposes
* ANT/Maven/Gradle for build
* Programmatic invocation of test for whatever purpose

##### The codebase of tests themselves should not be a part of the application distribution. Tests can be still run on top of this application
* For example, if the application is built as a WAR file that will be deployed in production, the jar module of tests should not be a part of the WAR
This allows really agile and fast development of test itself and doesn't bloat the distribution with unnecessary code

### Requirements:

* The JVM running the application will be of version 7 at least (java 8 is supported of course)
* The tests themselves will be written in [Spock framework](http://spockframework.org/) So some learning curve is required
The good news are that Spock itself is really a good tool so even if you don't know groovy, you'll be able to run spock after probably a hour of study
*Later on you'll probably discover that it works better even for other types of tests ;)*

>The concepts behind this framework can be easily implemented on top of Junit as well, Spock was taken solely 
>out of belief that developing tests in spock is much more easy and fun process than developing tests with JUnit (4.x at least).

* The framework _does require some change in application_ namely exposing a component that will accept remote connection on some tcp port 
and (optionally) the folder for storing the server side test reports. Since the server side component is fully customizable,
its perfectly valid to turn it off in production/protect the port with some kind of firewall 

### Basic Flow

Here is a schematic high level explanation of how to use the rtest framework

1. The architecture is a well-known client-server architecture. The application acts as a server and as such it should expose an opened port to accept connections.
2. The test running will always initiated on remote JVM (IDE, maven surefire plugin, and so forth) which will be referred as a client.  
   The host/port of the remote server should be supplied through some system variables (there are defaults of course)
   The test code will be compiled with server side classes in classpath, because the nature of test assumes that it has an access to the server side component
3. When the test actually starts, the framework contacts the server and asks to run the test. Since the bytecode of the test doesn't exist on server at this point, it will supplied dynamically,
   the framework handles this transparently
4. The server runs the test and obtains the results
5. The results get serialized back to the client
6. The client tool will render the result of test execution, like this test has been run locally and finished with the obtained result.
7. Since the reports can be generated by spock as a part of the framework, they are stored on the server side, but can be requested by client after the test has actually been run.
    
### More explanations 
TODO: Add me!
